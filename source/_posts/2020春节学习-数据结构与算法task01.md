---
title: 2020春节学习-数据结构与算法task01
tags:
  - 数据结构与算法
  - 学习
categories: 数据结构与算法
abbrlink: 24a04a3e
date: 2020-01-04 10:19:34
---

Task01：数组（1天）
理论部分

理解数组的存储与分类。
实现动态数组，该数组能够根据需要修改数组的长度。
练习部分
<!-- more -->
### 1.利用动态数组解决数据存放问题

编写一段代码，要求输入一个整数N，用动态数组A来存放2~N之间所有5或7的倍数，输出该数组。

示例：

输入：
N = 100 

输出：
5 7 10 14 15 20 21 25 28 30 35 40 42 45 49 50 55 56 60 63 65 70 75 77 80 84 85 90 91 95 98 100
1.方法一
```
def isToeplitzMatrix(num:int):
    data = []
    for i in range(1, num+1):
        if i % 5 == 0:
            data.append(i)
        elif i % 7 == 0:
            data.append(i)
    return " ".join(map(str,data))
    
```
2.方法二
```
def isToeplitzMatrix(num:int):
    data = []
    for i in range(1, num+1):
        if i * 5 <= num:
            data.append(i)
            if i * 7 <= num:
                data.append(i)
    return " ".join(map(str,data))
    
```

### 2.托普利茨矩阵问题
[leetcode原题766](https://leetcode-cn.com/problems/toeplitz-matrix/)
如果一个矩阵的每一方向由左上到右下的对角线上具有相同元素，那么这个矩阵是托普利茨矩阵。

给定一个M x N的矩阵，当且仅当它是托普利茨矩阵时返回True。

示例：

输入:
matrix = [
  [1,2,3,4],
  [5,1,2,3],
  [9,5,1,2]
]

输出: True
解释:

在上述矩阵中, 其对角线为: "[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]"。 各条对角线上的所有元素均相同, 因此答案是True。
1.方法一
算法与思路：首先要想明白的是怎么判断 (r1, c1 和 (r2, c2) 这两个点属于一条对角线，(r1,c2)和(r2, c3)这两个点属于同一条对角线。所以对角线上的两个点可以这么来表示：(r,c)和(r+1, c+1)
```
class Solution:
     def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:
         for i in range(len(matrix)-1):
             for j in range(len(matrix[i])-1):
                 if matrix[i][j] != matrix[i+1][j+1]:
                     return False
         return True
```
2.方法二
```
class Solution:
     def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:
        return not (True in [matrix[i][:-1] != matrix[i+1][1:] for i in range(len(matrix)-1)])
```
### 3.三数之和

[leetcode原题15](https://leetcode-cn.com/problems/3sum/)

给定一个包含 n 个整数的数组nums，判断nums中是否存在三个元素a，b，c，使得a + b + c = 0？找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

示例：

给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]

```
class Solution:
    def threeSum(self, nums: [int]) -> [[int]]:
        nums.sort()
        res, k = [], 0
        for k in range(len(nums) - 2):
            if nums[k] > 0: 
                break # 1. because of j > i > k.
            if k > 0 and nums[k] == nums[k - 1]: 
                continue # 2. skip the same `nums[k]`.
            i, j = k + 1, len(nums) - 1
            while i < j: # 3. double pointer
                s = nums[k] + nums[i] + nums[j]
                if s < 0:
                    i += 1
                    while i < j and nums[i] == nums[i - 1]: i += 1
                elif s > 0:
                    j -= 1
                    while i < j and nums[j] == nums[j + 1]: j -= 1
                else:
                    res.append([nums[k], nums[i], nums[j]])
                    i += 1
                    j -= 1
                    while i < j and nums[i] == nums[i - 1]: i += 1
                    while i < j and nums[j] == nums[j + 1]: j -= 1
        return res
```